[{"title":"Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案","date":"2018-01-22T05:27:22.000Z","path":"2018/01/22/Spring_Quartz_Job_Autowired/","text":"Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案1. 当时我有个项目要使用调度，所以选择Spring-Quartz，但是遇到了问题就是无法Autowired注入Service。2. 利用Quartz可以实现定时任务，但在跟Spring整合后，直接在Job中注解方式注入Service后运行却报空指针异常。原因是Quartz初始化是自己的JobContext，不同于Spring的ApplicationContext，所以无法直接注入 3.具体做法是直接getBean()的方式来获取service的1234567891011public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 4.关键代码就是RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class)。 后面附上我的spring.xml,Spring-Quartz.xml,和主要的java代码spring.xml123456789101112131415161718192021222324252627282930spring.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\" default-lazy-init=\"true\"&gt; &lt;description&gt;Spring Configuration&lt;/description&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:config.properties\" /&gt; &lt;!-- 加载应用属性实例，在JAVA类中可以 @Value(\"#&#123;APP_PROP['jdbc.driver']&#125;\") 来获取属性文件中jdbc.driver的值 --&gt; &lt;util:properties id=\"APP_PROP\" location=\"classpath:config.properties\" local-override=\"true\" /&gt; &lt;!-- Controller注解由springMVC扫描 --&gt; &lt;context:component-scan base-package=\"com.pactera\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!--注入spring-quartz--&gt; &lt;import resource=\"spring-quartz.xml\"/&gt;&lt;/beans&gt; spring-quartz.xml &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;!-- 配置调度器工厂(SchedulerFactoryBean) --&gt; &lt;bean name=\"startQuertz\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"myJobTrigger\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt; &lt;bean id=\"myJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\"&gt; &lt;ref bean=\"myJobDetail\" /&gt; &lt;/property&gt; &lt;property name=\"cronExpression\"&gt; &lt;!-- 每隔10分钟执行 --&gt; &lt;value&gt;0 0/2 * * * ?&lt;/value&gt; &lt;!-- &lt;value&gt;0/20 * * * * ?&lt;/value&gt; --&gt; &lt;!-- 每隔2小时 &lt;value&gt;* * */2 * * ?&lt;/value&gt; --&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置方法调用任务工厂(XXXJobDetailFactoryBean) --&gt; &lt;bean id=\"myJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\"&gt; &lt;ref bean=\"myJob\" /&gt; &lt;/property&gt; &lt;property name=\"targetMethod\"&gt; &lt;value&gt;doWork&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 工作的bean --&gt; &lt;bean id=\"myJob\" class=\"com.pactera.modules.sys.job.DispatchJob\" lazy-init=\"true\"&gt; &lt;/bean&gt; &lt;!--&amp;lt;!&amp;ndash; 工作的bean &amp;ndash;&amp;gt; &lt;bean id=\"myJob2\" class=\"com.pactera.modules.sys.job.DispatchWork\" lazy-init=\"true\"&gt; &lt;property name=\"runKettleSerive\" &gt; &lt;ref bean=\"unKettleSeriveImpl\" /&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;/beans&gt; DispatchJob.java package com.pactera.modules.sys.job; import com.pactera.common.support.CustomerContextHolder; import com.pactera.common.util.SchedulerUtil; import com.pactera.modules.datadistribute.services.DistributeShellService; import com.pactera.modules.distribute.service.DistributeWorkInfoService; import com.pactera.modules.runscipt.service.RunKettleSerive; import com.pactera.modules.runscipt.service.RunScriptService; import com.pactera.modules.settings.service.DamDependencyService; import com.pactera.modules.settings.service.DamFrequencyService; import com.pactera.modules.settings.service.DamVariableDatadateService; import org.apache.log4j.Logger; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.SchedulerFactory; import org.quartz.impl.StdSchedulerFactory; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.util.StringUtils; import java.text.SimpleDateFormat; import java.util.Arrays; import java.util.Date; import java.util.List; import java.util.Map; /** * Created by echo_ on 2017/12/8. * @author sxl */ public class DispatchJob { private static final Logger logger = Logger.getLogger(DispatchJob.class); @Autowired private DamVariableDatadateService damVariableDatadateService; @Autowired private DistributeShellService distributeShellService; @Autowired private DistributeWorkInfoService distributeWorkInfoService; @Autowired private RunScriptService runScriptService; @Autowired private RunKettleSerive runKettleScript; @Autowired private DamDependencyService damDependencyService; @Autowired private DamFrequencyService damFrequencyService; public void doWork() throws SchedulerException { doShellWork(); System.out.println(new Date()); } public void doShellWork() throws SchedulerException { CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE_DAM); List&lt;Map&lt;String, Object&gt;&gt; maps = distributeShellService.selectDistributeTask(); SchedulerFactory schedulerfactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerfactory.getScheduler(); for (int i=0;i&lt;maps.size();i++){ List&lt;String&gt; wid_List = Arrays.asList(StringUtils.commaDelimitedListToStringArray(maps.get(i).get(\"WORK_ID\").toString())); //作业idlist for (int k=0;k&lt;wid_List.size();k++){ SchedulerUtil.createScheduleJob(scheduler, maps.get(i).get(\"TASK_ID\").toString(), wid_List.get(k), damFrequencyService.selectTriggerRuleById(maps.get(i).get(\"TASK_ID\").toString()) , DispatchWork.class); } } CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE); } } ``` DispatchWork.java &lt;!--more--&gt; ``` javascript package com.pactera.modules.sys.job; import com.pactera.common.util.SpringContextHolder; import com.pactera.modules.runscipt.service.RunKettleSerive; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; /** * @author song * @date created in 2018-02-01 19:17 */ public class DispatchWork implements Job { @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException { String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); //这样就拿到service了 RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ } } 这几天需要用到定时任务调度，因此转向quartz的学习，特此记录下来。quartz使用起来及其方便，与spring整合配置，只需要写一个类继承QuartzJobBean，重写其executeInternal(JobExecutionContext arg0)即可，我们只需要将自己的逻辑代码写在该方法即可。一旦你配置好实现类并设定好调度时间，Quartz将密切注意剩余时间。当调度程序确定该是执行作业的时候，Quartz框架将调用你作业类上的executeInternal()方法并执行相应的任务。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它。 quartz有三个核心概念，调度器、任务和触发器。三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。概念相对应的类和接口有： 1）JobDetail：描述任务的相关情况，包括配置任务执行的类和方法。 2）Trigger：描述出发Job执行的时间触发规则。有SimpleTrigger和CronTrigger两个子类代表两种方式，一种是每隔多少分钟小时执行，则用SimpleTrigger；另一种是日历相关的重复时间间隔，如每天凌晨，每周星期一运行的话，通过Cron表达式便可定义出复杂的调度方案。 3）Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail要注册到Scheduler中才会生效，也就是让调度器知道有哪些触发器和任务，才能进行按规则进行调度任务。quartz的配置一般有两种，一种是配置无参数的任务，就是一个普通方法，要求该执行任务的方法必须为无参方法，否则会报错。另一种是配置可传参方法，因为这里我需要给任务传递一些参数，所以采用第二种配置方法。首先，需要下载quartz和spring对其提供支持的jar包。我这里采用的是quartz-2.2.1.jar，spring-context-support-4.2.4.RELEASE.jar，下载其他版本请注意包版本之间的兼容。","tags":[{"name":"文章","slug":"文章","permalink":"http://www.songxiaolang.com/tags/文章/"},{"name":"Quartz","slug":"Quartz","permalink":"http://www.songxiaolang.com/tags/Quartz/"}]},{"title":"AJAX POST数据中有特殊符号导致数据丢失的解决方法","date":"2016-09-22T05:27:22.000Z","path":"2016/09/22/data_exists_special_symbols/","text":"使用Ajax传送数据时，当数据中存在加号(+)、连接符(&amp;)或者百分号(%)时，服务器端接收数据时会丢失数据。分析Ajax传送数据的格式与Javascript的语法：1. “+”号：JavaScript解析为字符串连接符，所以服务器端接收数据时”+”会丢失变空格。2. “&amp;”号：JavaScript解析为变量连接符，所以服务器端接收数据时&amp;符号以后的数据都会丢失变空格。 解决方法是通过正则表达式进行编码替换(假设postStr是你想通过ajax传送的数据字符串)123postStr = postStr.replace(/\\%/g, \"%25\"); postStr = postStr.replace(/\\&amp;/g, \"%26\"); postStr = postStr.replace(/\\+/g, \"%2B\");","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://www.songxiaolang.com/tags/Ajax/"},{"name":"文章","slug":"文章","permalink":"http://www.songxiaolang.com/tags/文章/"}]}]