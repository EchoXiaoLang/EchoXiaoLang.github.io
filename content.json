[{"title":"java执行cmd命令是遇到一些特殊字符处理丢失","date":"2018-02-02T14:12:33.000Z","path":"2018/02/02/java_execCommand_StreamGobbler/","text":"：当时要执行kettle命令的时候，遇到kettle的命令符号丢失,当时使用的是123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142package com.pactera.common.util;import com.alibaba.fastjson.JSONObject;import org.apache.commons.cli.*;import org.apache.commons.exec.CommandLine;import org.apache.commons.exec.*;import org.junit.Test;import java.io.ByteArrayOutputStream;import java.util.Collection;/** * @author song * @date created in 2018-01-19 18:49 */public class ExecuteShell &#123; public static JSONObject callCMD(String shellInfo) &#123; System.out.println(\"Cmd接收到的命令---\"+shellInfo); JSONObject json = new JSONObject(); String error = \"\"; int execute = 1; String out=\"\"; try &#123; CommandLine commandline = CommandLine.parse(shellInfo); DefaultExecutor exec = new DefaultExecutor(); exec.setExitValue(0); ExecuteWatchdog watchdog = new ExecuteWatchdog(600 * 1000); exec.setWatchdog(watchdog); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); PumpStreamHandler streamHandler = new PumpStreamHandler(outputStream, errorStream); exec.setStreamHandler(streamHandler); execute = exec.execute(commandline); out = outputStream.toString(\"gbk\"); error = errorStream.toString(\"gbk\"); System.out.println(out); System.out.println(error); &#125; catch (Exception e) &#123; json.put(\"statusCode\", 1); json.put(\"msg\", \"Failed to call shell's command and the return status's is:1 \"+error ); &#125; json.put(\"statusCode\" , execute); json.put(\"msg\" , out); return json; &#125; /** * 创建commandline对象 * * @param args * @return * @throws ParseException */ private static CommandLine getCommandLine(String args, Options mergeOptions) throws ParseException &#123; CommandLineParser parser = new DefaultParser(); HelpFormatter hf = new HelpFormatter(); hf.printHelp(args, \"\", mergeOptions, \"\");// return parser.parse(mergeOptions, new String[]&#123;args&#125;); return null; &#125; /** * 合并options * * @param optionsArgs options项 * @return 合并后的options */ private static Options mergeOptions(Options... optionsArgs) &#123; Options allOptions = new Options(); // 合并所有options，如果不合并单独使用，会出现问题 for (Options options : optionsArgs) &#123; Collection&lt;Option&gt; options1 = options.getOptions(); for (Option option : options1) &#123; allOptions.addOption(option); &#125; &#125; return allOptions; &#125; @Test public void test() throws ParseException &#123; // 模拟命令行参数 String args = \"sdo\"; &#125; /* public static void main(String[] args) throws ParseException &#123; String argss[]=&#123;\"-t 1000\"&#125;; //定义 Options options = new Options(); options.addOption(\"ipconfig\", false, \"list help\");//false代表不强制有 options.addOption(\"ipconfig\", true, \"set time on system\"); //解析 //1.3.1中已经弃用针对不同格式入参对应的解析器 //CommandLineParser parser = new PosixParser(); CommandLineParser parser = new DefaultParser(); CommandLine cmd = parser.parse(options, args); //查询交互 //你的程序应当写在这里，从这里启动 String formatstr = \"ipconfig\"; HelpFormatter hf = new HelpFormatter(); hf.printHelp(formatstr, \"\", options, \"\"); return; &#125;*/ public static void main(String[] args) &#123; try &#123; String command = \" E:\\\\tool\\\\data-integration\\\\kitchen.bat /rep:kettle /dir:/ /user:admin /pass:admin /level:Basic /job:EDW_FENFA_JOB -param:\\\"DBTYPE=ORACLE\\\" -param:\\\"TABLE_NAME=omdata.S24_SEAT_HISTORY\\\" -param:\\\"EDW_TABLE_NAME=S24_SEAT_HISTORY\\\" -param:\\\"COLUMNS=T.ID,T.BUS_ID,T.LAST_REST,T.REST,T.LAST_UPDATETIME,T.UPDATE_TIME\\\" -param:\\\"USER_NAME=yyy\\\" -param:\\\"CONDITIONS=TO_DATE('20160310','YYYYMMDD')=T.ETL_DT\\\" -param:\\\"DATA_DT=20160310\\\"\"; CommandLine commandline = CommandLine.parse(command); DefaultExecutor exec = new DefaultExecutor(); exec.setExitValue(0); ExecuteWatchdog watchdog = new ExecuteWatchdog(60*1000); exec.setWatchdog(watchdog); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); ByteArrayOutputStream errorStream = new ByteArrayOutputStream(); PumpStreamHandler streamHandler = new PumpStreamHandler(outputStream,errorStream); exec.setStreamHandler(streamHandler); int execute = exec.execute(commandline); String out = outputStream.toString(\"gbk\"); String error = errorStream.toString(\"gbk\"); System.out.println(\"out\"+out); System.out.println(\"error\"+error); System.out.println(\"exit: \" + execute); &#125; catch (Exception e) &#123; return; &#125; &#125;&#125; 1. 我当时运行的时候 CommandLine commandline = CommandLine.parse(shellInfo);的时候，命令还是正常的，到了处理的时候execute = exec.execute(commandline);就导致了命令符号的一些丢失，比如；=2. 后来想了很久，查找很多资料换了一种方式处理，不能通过转义字符来处理，为什么不换一种处理cmd命令的方式了，后来换了如下方式就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.pactera.common.util;/** * @author song * @date created in 2018-02-01 15:36 */import com.alibaba.fastjson.JSONObject;import com.pactera.common.model.ResultModel;import org.apache.log4j.Logger;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class CallCmdUtils &#123; private static Logger logger = Logger.getLogger(CallCmdUtils.class); public static void executeCmd(String cmd)&#123; if(cmd == null || cmd.equals(\"\"))&#123; return; &#125; logger.info(\"执行命令：\"+cmd); String[] cmds = new String[]&#123;\"/bin/sh\",\"-c\",cmd&#125;; try &#123; Runtime.getRuntime().exec(cmds); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 执行本地命令 cmd格式 windows 环境下查询360运行exe程序： cmd /c tasklist | findstr * \"360.*[.exe]\" * * @param cmd * @return */ public static ResultModel executeLocalCmd(String cmd) &#123; ResultModel model = null; if(cmd == null || cmd.equals(\"\"))&#123; model.setStatusCode(\"1\"); return model; &#125; logger.info(\"执行命令：\"+cmd); String[] cmds = new String[]&#123;cmd&#125;; StringBuffer sb = new StringBuffer(255); try &#123; Process process = Runtime.getRuntime().exec(cmds); process.waitFor(); int result = process.exitValue(); if(result == 0)&#123; /* model.setStatusCode(\"0\");*/ InputStream in = process.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String dataline = null; while ((dataline = br.readLine()) != null) &#123; sb.append(dataline).append(\"\\n\"); &#125; br.close(); in.close(); /*model.setMessage(sb.toString().trim());*/ &#125;else&#123; InputStream in = process.getErrorStream(); BufferedReader br = new BufferedReader(new InputStreamReader(in)); String dataline = null; while ((dataline = br.readLine()) != null) &#123; sb.append(dataline).append(\"\\n\"); &#125; br.close(); in.close(); /* model.setStatusCode(\"1\"); model.setMessage(sb.toString().trim());*/ &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return model; &#125; public static JSONObject execCommand(String command)&#123; JSONObject json = new JSONObject(); int execute = 0; try &#123; Process proc = Runtime.getRuntime().exec(command); //为了防止命令进程阻塞，添加两线程处理输出信息 new StreamGobbler(proc.getErrorStream(),\"[\"+command+\"]ERROR\").start(); new StreamGobbler(proc.getInputStream(),\"[\"+command+\"]STDOUT\").start(); if(proc.waitFor()==0)&#123; logger.error(\"执行[\"+command+\"]命令成功\"); json.put(\"statusCode\", 0); json.put(\"msg\" , \"执行[\"+command+\"]命令成功\"); &#125;else&#123; logger.error(\"执行[\"+command+\"]命令出错\"); json.put(\"statusCode\", 1); json.put(\"msg\" , \"执行[\"+command+\"]命令出错\"); &#125; &#125; catch (IOException ex) &#123; logger.error(\"执行[\"+command+\"]命令IO异常\",ex); json.put(\"msg\" , \"执行[\"+command+\"]命令IO异常\"+ex); json.put(\"statusCode\", 1); &#125; catch (InterruptedException ex) &#123; logger.error(\"执行[\"+command+\"]命令被中断\",ex); json.put(\"msg\" , \"执行[\"+command+\"]命令被中断\"+ex); json.put(\"statusCode\", 1); &#125; return json; &#125;&#125; 我试了几个方法，后来用了最后一个：execCommand(String command)这个方法就可以了。在附上一个帮助StreamGobbler.java 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.pactera.common.util;/** * @author song * @date created in 2018-02-01 15:37 */import org.apache.log4j.Logger;import java.io.*;/** * 用于处理Runtime.getRuntime().exec产生的错误流及输出流 * @author shaojing * */public class StreamGobbler extends Thread &#123; static Logger logger = Logger.getLogger(StreamGobbler.class); InputStream is; String type; OutputStream os; public StreamGobbler(InputStream is, String type) &#123; this(is, type, null); &#125; public StreamGobbler(InputStream is, String type, OutputStream redirect) &#123; this.is = is; this.type = type; this.os = redirect; &#125; public void run() &#123; InputStreamReader isr = null; BufferedReader br = null; PrintWriter pw = null; try &#123; if (os != null) pw = new PrintWriter(os); isr = new InputStreamReader(is); br = new BufferedReader(isr); String line=null; while ( (line = br.readLine()) != null) &#123; if (pw != null) pw.println(line); logger.info(type + \"&gt;\" + line); &#125; if (pw != null) pw.flush(); &#125; catch (IOException ioe) &#123; ioe.printStackTrace(); &#125; finally&#123; if(pw != null)&#123; pw.close(); pw = null; &#125; if(isr != null)&#123; try &#123; isr.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; isr = null; &#125; if(br != null)&#123; try &#123; br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; br = null; &#125; &#125; &#125;&#125; 总结：当遇到问题的，不能只往一个方向钻，可以换种方式处理，总能找到适合自己的方法。","tags":[{"name":"文章","slug":"文章","permalink":"http://www.songxiaolang.com/tags/文章/"},{"name":"java_execCommand","slug":"java-execCommand","permalink":"http://www.songxiaolang.com/tags/java-execCommand/"}]},{"title":"Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案","date":"2018-01-22T05:27:22.000Z","path":"2018/01/22/Spring_Quartz_Job_Autowired/","text":"Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案1. 当时我有个项目要使用调度，所以选择Spring-Quartz，但是遇到了问题就是无法Autowired注入Service。2. 利用Quartz可以实现定时任务，但在跟Spring整合后，直接在Job中注解方式注入Service后运行却报空指针异常。原因是Quartz初始化是自己的JobContext，不同于Spring的ApplicationContext，所以无法直接注入 3.具体做法是直接getBean()的方式来获取service的1234567891011public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 4.关键代码就是RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class)。 后面附上我的spring.xml,Spring-Quartz.xml,和主要的java代码spring.xml123456789101112131415161718192021222324252627spring.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\" default-lazy-init=\"true\"&gt; &lt;description&gt;Spring Configuration&lt;/description&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:config.properties\" /&gt; &lt;!-- 加载应用属性实例，在JAVA类中可以 @Value(\"#&#123;APP_PROP['jdbc.driver']&#125;\") 来获取属性文件中jdbc.driver的值 --&gt; &lt;util:properties id=\"APP_PROP\" location=\"classpath:config.properties\" local-override=\"true\" /&gt; &lt;!-- Controller注解由springMVC扫描 --&gt; &lt;context:component-scan base-package=\"com.pactera\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!--注入spring-quartz--&gt; &lt;import resource=\"spring-quartz.xml\"/&gt;&lt;/beans&gt; spring-quartz.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;!-- 配置调度器工厂(SchedulerFactoryBean) --&gt; &lt;bean name=\"startQuertz\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"myJobTrigger\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt; &lt;bean id=\"myJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\"&gt; &lt;ref bean=\"myJobDetail\" /&gt; &lt;/property&gt; &lt;property name=\"cronExpression\"&gt; &lt;!-- 每隔10分钟执行 --&gt; &lt;value&gt;0 0/2 * * * ?&lt;/value&gt;&lt;!-- &lt;value&gt;0/20 * * * * ?&lt;/value&gt; --&gt;&lt;!-- 每隔2小时 &lt;value&gt;* * */2 * * ?&lt;/value&gt; --&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置方法调用任务工厂(XXXJobDetailFactoryBean) --&gt; &lt;bean id=\"myJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\"&gt; &lt;ref bean=\"myJob\" /&gt; &lt;/property&gt; &lt;property name=\"targetMethod\"&gt; &lt;value&gt;doWork&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 工作的bean --&gt; &lt;bean id=\"myJob\" class=\"com.pactera.modules.sys.job.DispatchJob\" lazy-init=\"true\"&gt; &lt;/bean&gt; &lt;!--&amp;lt;!&amp;ndash; 工作的bean &amp;ndash;&amp;gt; &lt;bean id=\"myJob2\" class=\"com.pactera.modules.sys.job.DispatchWork\" lazy-init=\"true\"&gt; &lt;property name=\"runKettleSerive\" &gt; &lt;ref bean=\"unKettleSeriveImpl\" /&gt; &lt;/property&gt; &lt;/bean&gt;--&gt;&lt;/beans&gt; DispatchJob.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import com.pactera.common.support.CustomerContextHolder;import com.pactera.common.util.SchedulerUtil;import com.pactera.modules.datadistribute.services.DistributeShellService;import com.pactera.modules.distribute.service.DistributeWorkInfoService;import com.pactera.modules.runscipt.service.RunKettleSerive;import com.pactera.modules.runscipt.service.RunScriptService;import com.pactera.modules.settings.service.DamDependencyService;import com.pactera.modules.settings.service.DamFrequencyService;import com.pactera.modules.settings.service.DamVariableDatadateService;import org.apache.log4j.Logger;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.impl.StdSchedulerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.util.StringUtils;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;/** * Created by echo_ on 2017/12/8. * @author sxl */public class DispatchJob &#123; private static final Logger logger = Logger.getLogger(DispatchJob.class); @Autowired private DamVariableDatadateService damVariableDatadateService; @Autowired private DistributeShellService distributeShellService; @Autowired private DistributeWorkInfoService distributeWorkInfoService; @Autowired private RunScriptService runScriptService; @Autowired private RunKettleSerive runKettleScript; @Autowired private DamDependencyService damDependencyService; @Autowired private DamFrequencyService damFrequencyService; public void doWork() throws SchedulerException &#123; doShellWork(); System.out.println(new Date()); &#125; public void doShellWork() throws SchedulerException &#123; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE_DAM); List&lt;Map&lt;String, Object&gt;&gt; maps = distributeShellService.selectDistributeTask(); SchedulerFactory schedulerfactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerfactory.getScheduler(); for (int i=0;i&lt;maps.size();i++)&#123; List&lt;String&gt; wid_List = Arrays.asList(StringUtils.commaDelimitedListToStringArray(maps.get(i).get(\"WORK_ID\").toString())); //作业idlist for (int k=0;k&lt;wid_List.size();k++)&#123; SchedulerUtil.createScheduleJob(scheduler, maps.get(i).get(\"TASK_ID\").toString(), wid_List.get(k), damFrequencyService.selectTriggerRuleById(maps.get(i).get(\"TASK_ID\").toString()) , DispatchWork.class); &#125; &#125; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE); &#125;&#125; DispatchWork.java 123456789101112131415161718192021222324package com.pactera.modules.sys.job;import com.pactera.common.util.SpringContextHolder;import com.pactera.modules.runscipt.service.RunKettleSerive;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;/** * @author song * @date created in 2018-02-01 19:17 */public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); //这样就拿到service了 RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 接口SchedulerUtil，处理调度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.pactera.common.util;import com.pactera.modules.sys.job.DispatchWork;import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;/** * @author song * @date created in 2018-01-19 15:35 */public class SchedulerUtil &#123; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression * @param clazz job class */ public static void createScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression, Class&lt;? extends Job&gt; clazz) throws SchedulerException &#123; //通过schedulerFactory获取一个调度器 SchedulerFactory schedulerfactory=new StdSchedulerFactory(); try&#123;// 通过schedulerFactory获取一个调度器 scheduler=schedulerfactory.getScheduler();// 创建jobDetail实例，绑定Job实现类// 指明job的名称，所在组的名称，以及绑定job类 JobDetail job= JobBuilder.newJob(DispatchWork.class).withIdentity(jobName, jobGroup).build(); Trigger trigger=TriggerBuilder.newTrigger().withIdentity(jobName, jobGroup) .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)) .startNow().build();// 把作业和触发器注册到任务调度中 scheduler.scheduleJob(job, trigger);// 启动调度 scheduler.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression */ public static void updateScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression) throws SchedulerException &#123; TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroup); //获取trigger，即在spring配置文件中定义的 bean id=\"myTrigger\" CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey); //表达式调度构建器 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression); //按新的cronExpression表达式重新构建trigger try &#123; trigger = trigger.getTriggerBuilder().withIdentity(triggerKey) .withSchedule(scheduleBuilder).build(); &#125;catch (Exception e)&#123; System.out.println(\"errMsg\"+e); return; &#125; //按新的trigger重新设置job执行 scheduler.rescheduleJob(triggerKey, trigger); &#125; /** * 暂停任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void pauseJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.pauseJob(jobKey); &#125; /** * 恢复任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void resumeJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.resumeJob(jobKey); &#125; /** * 删除任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void deleteJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.deleteJob(jobKey); &#125; /** * 立即运行 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void triggerJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.triggerJob(jobKey); &#125;&#125; 这几天需要用到定时任务调度，因此转向quartz的学习，特此记录下来。quartz使用起来及其方便，与spring整合配置，只需要写一个类继承QuartzJobBean，重写其executeInternal(JobExecutionContext arg0)即可，我们只需要将自己的逻辑代码写在该方法即可。一旦你配置好实现类并设定好调度时间，Quartz将密切注意剩余时间。当调度程序确定该是执行作业的时候，Quartz框架将调用你作业类上的executeInternal()方法并执行相应的任务。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它。 quartz有三个核心概念，调度器、任务和触发器。三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。概念相对应的类和接口有： 1）JobDetail：描述任务的相关情况，包括配置任务执行的类和方法。 2）Trigger：描述出发Job执行的时间触发规则。有SimpleTrigger和CronTrigger两个子类代表两种方式，一种是每隔多少分钟小时执行，则用SimpleTrigger；另一种是日历相关的重复时间间隔，如每天凌晨，每周星期一运行的话，通过Cron表达式便可定义出复杂的调度方案。 3）Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail要注册到Scheduler中才会生效，也就是让调度器知道有哪些触发器和任务，才能进行按规则进行调度任务。quartz的配置一般有两种，一种是配置无参数的任务，就是一个普通方法，要求该执行任务的方法必须为无参方法，否则会报错。另一种是配置可传参方法，因为这里我需要给任务传递一些参数，所以采用第二种配置方法。 首先，需要下载quartz和spring对其提供支持的jar包。我这里采用的是quartz-2.2.1.jar，spring-context-support-4.2.4.RELEASE.jar，下载其他版本请注意包版本之间的兼容。 title: Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案tags: Quartz 文章categories: Springdate: 2018-01-22 13:27:22permalink: Spring_Quartz_Job_Autowired Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案1. 当时我有个项目要使用调度，所以选择Spring-Quartz，但是遇到了问题就是无法Autowired注入Service。2. 利用Quartz可以实现定时任务，但在跟Spring整合后，直接在Job中注解方式注入Service后运行却报空指针异常。原因是Quartz初始化是自己的JobContext，不同于Spring的ApplicationContext，所以无法直接注入 3.具体做法是直接getBean()的方式来获取service的1234567891011public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 4.关键代码就是RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class)。 后面附上我的spring.xml,Spring-Quartz.xml,和主要的java代码spring.xml123456789101112131415161718192021222324252627spring.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\" default-lazy-init=\"true\"&gt; &lt;description&gt;Spring Configuration&lt;/description&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:config.properties\" /&gt; &lt;!-- 加载应用属性实例，在JAVA类中可以 @Value(\"#&#123;APP_PROP['jdbc.driver']&#125;\") 来获取属性文件中jdbc.driver的值 --&gt; &lt;util:properties id=\"APP_PROP\" location=\"classpath:config.properties\" local-override=\"true\" /&gt; &lt;!-- Controller注解由springMVC扫描 --&gt; &lt;context:component-scan base-package=\"com.pactera\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!--注入spring-quartz--&gt; &lt;import resource=\"spring-quartz.xml\"/&gt;&lt;/beans&gt; spring-quartz.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;!-- 配置调度器工厂(SchedulerFactoryBean) --&gt; &lt;bean name=\"startQuertz\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"myJobTrigger\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt; &lt;bean id=\"myJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\"&gt; &lt;ref bean=\"myJobDetail\" /&gt; &lt;/property&gt; &lt;property name=\"cronExpression\"&gt; &lt;!-- 每隔10分钟执行 --&gt; &lt;value&gt;0 0/2 * * * ?&lt;/value&gt;&lt;!-- &lt;value&gt;0/20 * * * * ?&lt;/value&gt; --&gt;&lt;!-- 每隔2小时 &lt;value&gt;* * */2 * * ?&lt;/value&gt; --&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置方法调用任务工厂(XXXJobDetailFactoryBean) --&gt; &lt;bean id=\"myJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\"&gt; &lt;ref bean=\"myJob\" /&gt; &lt;/property&gt; &lt;property name=\"targetMethod\"&gt; &lt;value&gt;doWork&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 工作的bean --&gt; &lt;bean id=\"myJob\" class=\"com.pactera.modules.sys.job.DispatchJob\" lazy-init=\"true\"&gt; &lt;/bean&gt; &lt;!--&amp;lt;!&amp;ndash; 工作的bean &amp;ndash;&amp;gt; &lt;bean id=\"myJob2\" class=\"com.pactera.modules.sys.job.DispatchWork\" lazy-init=\"true\"&gt; &lt;property name=\"runKettleSerive\" &gt; &lt;ref bean=\"unKettleSeriveImpl\" /&gt; &lt;/property&gt; &lt;/bean&gt;--&gt;&lt;/beans&gt; DispatchJob.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import com.pactera.common.support.CustomerContextHolder;import com.pactera.common.util.SchedulerUtil;import com.pactera.modules.datadistribute.services.DistributeShellService;import com.pactera.modules.distribute.service.DistributeWorkInfoService;import com.pactera.modules.runscipt.service.RunKettleSerive;import com.pactera.modules.runscipt.service.RunScriptService;import com.pactera.modules.settings.service.DamDependencyService;import com.pactera.modules.settings.service.DamFrequencyService;import com.pactera.modules.settings.service.DamVariableDatadateService;import org.apache.log4j.Logger;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.impl.StdSchedulerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.util.StringUtils;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;/** * Created by echo_ on 2017/12/8. * @author sxl */public class DispatchJob &#123; private static final Logger logger = Logger.getLogger(DispatchJob.class); @Autowired private DamVariableDatadateService damVariableDatadateService; @Autowired private DistributeShellService distributeShellService; @Autowired private DistributeWorkInfoService distributeWorkInfoService; @Autowired private RunScriptService runScriptService; @Autowired private RunKettleSerive runKettleScript; @Autowired private DamDependencyService damDependencyService; @Autowired private DamFrequencyService damFrequencyService; public void doWork() throws SchedulerException &#123; doShellWork(); System.out.println(new Date()); &#125; public void doShellWork() throws SchedulerException &#123; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE_DAM); List&lt;Map&lt;String, Object&gt;&gt; maps = distributeShellService.selectDistributeTask(); SchedulerFactory schedulerfactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerfactory.getScheduler(); for (int i=0;i&lt;maps.size();i++)&#123; List&lt;String&gt; wid_List = Arrays.asList(StringUtils.commaDelimitedListToStringArray(maps.get(i).get(\"WORK_ID\").toString())); //作业idlist for (int k=0;k&lt;wid_List.size();k++)&#123; SchedulerUtil.createScheduleJob(scheduler, maps.get(i).get(\"TASK_ID\").toString(), wid_List.get(k), damFrequencyService.selectTriggerRuleById(maps.get(i).get(\"TASK_ID\").toString()) , DispatchWork.class); &#125; &#125; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE); &#125;&#125; DispatchWork.java 123456789101112131415161718192021222324package com.pactera.modules.sys.job;import com.pactera.common.util.SpringContextHolder;import com.pactera.modules.runscipt.service.RunKettleSerive;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;/** * @author song * @date created in 2018-02-01 19:17 */public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); //这样就拿到service了 RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 接口SchedulerUtil，处理调度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.pactera.common.util;import com.pactera.modules.sys.job.DispatchWork;import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;/** * @author song * @date created in 2018-01-19 15:35 */public class SchedulerUtil &#123; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression * @param clazz job class */ public static void createScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression, Class&lt;? extends Job&gt; clazz) throws SchedulerException &#123; //通过schedulerFactory获取一个调度器 SchedulerFactory schedulerfactory=new StdSchedulerFactory(); try&#123;// 通过schedulerFactory获取一个调度器 scheduler=schedulerfactory.getScheduler();// 创建jobDetail实例，绑定Job实现类// 指明job的名称，所在组的名称，以及绑定job类 JobDetail job= JobBuilder.newJob(DispatchWork.class).withIdentity(jobName, jobGroup).build(); Trigger trigger=TriggerBuilder.newTrigger().withIdentity(jobName, jobGroup) .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)) .startNow().build();// 把作业和触发器注册到任务调度中 scheduler.scheduleJob(job, trigger);// 启动调度 scheduler.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression */ public static void updateScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression) throws SchedulerException &#123; TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroup); //获取trigger，即在spring配置文件中定义的 bean id=\"myTrigger\" CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey); //表达式调度构建器 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression); //按新的cronExpression表达式重新构建trigger try &#123; trigger = trigger.getTriggerBuilder().withIdentity(triggerKey) .withSchedule(scheduleBuilder).build(); &#125;catch (Exception e)&#123; System.out.println(\"errMsg\"+e); return; &#125; //按新的trigger重新设置job执行 scheduler.rescheduleJob(triggerKey, trigger); &#125; /** * 暂停任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void pauseJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.pauseJob(jobKey); &#125; /** * 恢复任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void resumeJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.resumeJob(jobKey); &#125; /** * 删除任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void deleteJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.deleteJob(jobKey); &#125; /** * 立即运行 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void triggerJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.triggerJob(jobKey); &#125;&#125; 这几天需要用到定时任务调度，因此转向quartz的学习，特此记录下来。quartz使用起来及其方便，与spring整合配置，只需要写一个类继承QuartzJobBean，重写其executeInternal(JobExecutionContext arg0)即可，我们只需要将自己的逻辑代码写在该方法即可。一旦你配置好实现类并设定好调度时间，Quartz将密切注意剩余时间。当调度程序确定该是执行作业的时候，Quartz框架将调用你作业类上的executeInternal()方法并执行相应的任务。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它。 quartz有三个核心概念，调度器、任务和触发器。三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。概念相对应的类和接口有： 1）JobDetail：描述任务的相关情况，包括配置任务执行的类和方法。 2）Trigger：描述出发Job执行的时间触发规则。有SimpleTrigger和CronTrigger两个子类代表两种方式，一种是每隔多少分钟小时执行，则用SimpleTrigger；另一种是日历相关的重复时间间隔，如每天凌晨，每周星期一运行的话，通过Cron表达式便可定义出复杂的调度方案。 3）Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail要注册到Scheduler中才会生效，也就是让调度器知道有哪些触发器和任务，才能进行按规则进行调度任务。quartz的配置一般有两种，一种是配置无参数的任务，就是一个普通方法，要求该执行任务的方法必须为无参方法，否则会报错。另一种是配置可传参方法，因为这里我需要给任务传递一些参数，所以采用第二种配置方法。 首先，需要下载quartz和spring对其提供支持的jar包。我这里采用的是quartz-2.2.1.jar，spring-context-support-4.2.4.RELEASE.jar，下载其他版本请注意包版本之间的兼容。 title: Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案tags: Quartz 文章categories: Springdate: 2018-01-22 13:27:22permalink: Spring_Quartz_Job_Autowired Spring使用Quartz定时调度Job无法Autowired注入Service的解决方案1. 当时我有个项目要使用调度，所以选择Spring-Quartz，但是遇到了问题就是无法Autowired注入Service。2. 利用Quartz可以实现定时任务，但在跟Spring整合后，直接在Job中注解方式注入Service后运行却报空指针异常。原因是Quartz初始化是自己的JobContext，不同于Spring的ApplicationContext，所以无法直接注入 3.具体做法是直接getBean()的方式来获取service的1234567891011public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 4.关键代码就是RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class)。 后面附上我的spring.xml,Spring-Quartz.xml,和主要的java代码spring.xml123456789101112131415161718192021222324252627spring.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:task=\"http://www.springframework.org/schema/task\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd\" default-lazy-init=\"true\"&gt; &lt;description&gt;Spring Configuration&lt;/description&gt; &lt;!-- 加载配置属性文件 --&gt; &lt;context:property-placeholder ignore-unresolvable=\"true\" location=\"classpath:config.properties\" /&gt; &lt;!-- 加载应用属性实例，在JAVA类中可以 @Value(\"#&#123;APP_PROP['jdbc.driver']&#125;\") 来获取属性文件中jdbc.driver的值 --&gt; &lt;util:properties id=\"APP_PROP\" location=\"classpath:config.properties\" local-override=\"true\" /&gt; &lt;!-- Controller注解由springMVC扫描 --&gt; &lt;context:component-scan base-package=\"com.pactera\"&gt;&lt;!-- base-package 如果多个，用“,”分隔 --&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\" /&gt; &lt;/context:component-scan&gt; &lt;!--注入spring-quartz--&gt; &lt;import resource=\"spring-quartz.xml\"/&gt;&lt;/beans&gt; spring-quartz.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.0.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx-3.0.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.0.xsd\"&gt; &lt;!-- 配置调度器工厂(SchedulerFactoryBean) --&gt; &lt;bean name=\"startQuertz\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\"&gt; &lt;property name=\"triggers\"&gt; &lt;list&gt; &lt;ref bean=\"myJobTrigger\" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置Cron触发器(CronTriggerFactoryBean) --&gt; &lt;bean id=\"myJobTrigger\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\"&gt; &lt;property name=\"jobDetail\"&gt; &lt;ref bean=\"myJobDetail\" /&gt; &lt;/property&gt; &lt;property name=\"cronExpression\"&gt; &lt;!-- 每隔10分钟执行 --&gt; &lt;value&gt;0 0/2 * * * ?&lt;/value&gt;&lt;!-- &lt;value&gt;0/20 * * * * ?&lt;/value&gt; --&gt;&lt;!-- 每隔2小时 &lt;value&gt;* * */2 * * ?&lt;/value&gt; --&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置方法调用任务工厂(XXXJobDetailFactoryBean) --&gt; &lt;bean id=\"myJobDetail\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\"&gt; &lt;property name=\"targetObject\"&gt; &lt;ref bean=\"myJob\" /&gt; &lt;/property&gt; &lt;property name=\"targetMethod\"&gt; &lt;value&gt;doWork&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 工作的bean --&gt; &lt;bean id=\"myJob\" class=\"com.pactera.modules.sys.job.DispatchJob\" lazy-init=\"true\"&gt; &lt;/bean&gt; &lt;!--&amp;lt;!&amp;ndash; 工作的bean &amp;ndash;&amp;gt; &lt;bean id=\"myJob2\" class=\"com.pactera.modules.sys.job.DispatchWork\" lazy-init=\"true\"&gt; &lt;property name=\"runKettleSerive\" &gt; &lt;ref bean=\"unKettleSeriveImpl\" /&gt; &lt;/property&gt; &lt;/bean&gt;--&gt;&lt;/beans&gt; DispatchJob.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import com.pactera.common.support.CustomerContextHolder;import com.pactera.common.util.SchedulerUtil;import com.pactera.modules.datadistribute.services.DistributeShellService;import com.pactera.modules.distribute.service.DistributeWorkInfoService;import com.pactera.modules.runscipt.service.RunKettleSerive;import com.pactera.modules.runscipt.service.RunScriptService;import com.pactera.modules.settings.service.DamDependencyService;import com.pactera.modules.settings.service.DamFrequencyService;import com.pactera.modules.settings.service.DamVariableDatadateService;import org.apache.log4j.Logger;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.impl.StdSchedulerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.util.StringUtils;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;import java.util.List;import java.util.Map;/** * Created by echo_ on 2017/12/8. * @author sxl */public class DispatchJob &#123; private static final Logger logger = Logger.getLogger(DispatchJob.class); @Autowired private DamVariableDatadateService damVariableDatadateService; @Autowired private DistributeShellService distributeShellService; @Autowired private DistributeWorkInfoService distributeWorkInfoService; @Autowired private RunScriptService runScriptService; @Autowired private RunKettleSerive runKettleScript; @Autowired private DamDependencyService damDependencyService; @Autowired private DamFrequencyService damFrequencyService; public void doWork() throws SchedulerException &#123; doShellWork(); System.out.println(new Date()); &#125; public void doShellWork() throws SchedulerException &#123; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE_DAM); List&lt;Map&lt;String, Object&gt;&gt; maps = distributeShellService.selectDistributeTask(); SchedulerFactory schedulerfactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerfactory.getScheduler(); for (int i=0;i&lt;maps.size();i++)&#123; List&lt;String&gt; wid_List = Arrays.asList(StringUtils.commaDelimitedListToStringArray(maps.get(i).get(\"WORK_ID\").toString())); //作业idlist for (int k=0;k&lt;wid_List.size();k++)&#123; SchedulerUtil.createScheduleJob(scheduler, maps.get(i).get(\"TASK_ID\").toString(), wid_List.get(k), damFrequencyService.selectTriggerRuleById(maps.get(i).get(\"TASK_ID\").toString()) , DispatchWork.class); &#125; &#125; CustomerContextHolder.setCustomerType(CustomerContextHolder.DATA_SOURCE); &#125;&#125; DispatchWork.java 123456789101112131415161718192021222324package com.pactera.modules.sys.job;import com.pactera.common.util.SpringContextHolder;import com.pactera.modules.runscipt.service.RunKettleSerive;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;/** * @author song * @date created in 2018-02-01 19:17 */public class DispatchWork implements Job &#123; @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; String jobName = jobExecutionContext.getJobDetail().getKey().getName(); String group = jobExecutionContext.getTrigger().getKey().getGroup(); //这样就拿到service了 RunKettleSerive runKettleSerive= SpringContextHolder.getBean(RunKettleSerive.class); runKettleSerive.runKettleScript(jobName,group); /* runKettleSerive.runKettleScript(jobName,group);*/ &#125;&#125; 接口SchedulerUtil，处理调度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.pactera.common.util;import com.pactera.modules.sys.job.DispatchWork;import org.quartz.*;import org.quartz.impl.StdSchedulerFactory;/** * @author song * @date created in 2018-01-19 15:35 */public class SchedulerUtil &#123; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression * @param clazz job class */ public static void createScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression, Class&lt;? extends Job&gt; clazz) throws SchedulerException &#123; //通过schedulerFactory获取一个调度器 SchedulerFactory schedulerfactory=new StdSchedulerFactory(); try&#123;// 通过schedulerFactory获取一个调度器 scheduler=schedulerfactory.getScheduler();// 创建jobDetail实例，绑定Job实现类// 指明job的名称，所在组的名称，以及绑定job类 JobDetail job= JobBuilder.newJob(DispatchWork.class).withIdentity(jobName, jobGroup).build(); Trigger trigger=TriggerBuilder.newTrigger().withIdentity(jobName, jobGroup) .withSchedule(CronScheduleBuilder.cronSchedule(cronExpression)) .startNow().build();// 把作业和触发器注册到任务调度中 scheduler.scheduleJob(job, trigger);// 启动调度 scheduler.start(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; /** * 创建定时任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group * @param cronExpression the cron expression */ public static void updateScheduleJob(Scheduler scheduler, String jobName, String jobGroup, String cronExpression) throws SchedulerException &#123; TriggerKey triggerKey = TriggerKey.triggerKey(jobName, jobGroup); //获取trigger，即在spring配置文件中定义的 bean id=\"myTrigger\" CronTrigger trigger = (CronTrigger) scheduler.getTrigger(triggerKey); //表达式调度构建器 CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(cronExpression); //按新的cronExpression表达式重新构建trigger try &#123; trigger = trigger.getTriggerBuilder().withIdentity(triggerKey) .withSchedule(scheduleBuilder).build(); &#125;catch (Exception e)&#123; System.out.println(\"errMsg\"+e); return; &#125; //按新的trigger重新设置job执行 scheduler.rescheduleJob(triggerKey, trigger); &#125; /** * 暂停任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void pauseJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.pauseJob(jobKey); &#125; /** * 恢复任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void resumeJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.resumeJob(jobKey); &#125; /** * 删除任务 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void deleteJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.deleteJob(jobKey); &#125; /** * 立即运行 * * @param scheduler the scheduler * @param jobName the job name * @param jobGroup the job group */ public static void triggerJob(Scheduler scheduler, String jobName, String jobGroup) throws SchedulerException &#123; JobKey jobKey = JobKey.jobKey(jobName, jobGroup); scheduler.triggerJob(jobKey); &#125;&#125; 这几天需要用到定时任务调度，因此转向quartz的学习，特此记录下来。quartz使用起来及其方便，与spring整合配置，只需要写一个类继承QuartzJobBean，重写其executeInternal(JobExecutionContext arg0)即可，我们只需要将自己的逻辑代码写在该方法即可。一旦你配置好实现类并设定好调度时间，Quartz将密切注意剩余时间。当调度程序确定该是执行作业的时候，Quartz框架将调用你作业类上的executeInternal()方法并执行相应的任务。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它。 quartz有三个核心概念，调度器、任务和触发器。三者关系简单来说就是，调度器负责调度各个任务，到了某个时刻或者过了一定时间，触发器触动了，特定任务便启动执行。概念相对应的类和接口有： 1）JobDetail：描述任务的相关情况，包括配置任务执行的类和方法。 2）Trigger：描述出发Job执行的时间触发规则。有SimpleTrigger和CronTrigger两个子类代表两种方式，一种是每隔多少分钟小时执行，则用SimpleTrigger；另一种是日历相关的重复时间间隔，如每天凌晨，每周星期一运行的话，通过Cron表达式便可定义出复杂的调度方案。 3）Scheduler：代表一个Quartz的独立运行容器，Trigger和JobDetail要注册到Scheduler中才会生效，也就是让调度器知道有哪些触发器和任务，才能进行按规则进行调度任务。quartz的配置一般有两种，一种是配置无参数的任务，就是一个普通方法，要求该执行任务的方法必须为无参方法，否则会报错。另一种是配置可传参方法，因为这里我需要给任务传递一些参数，所以采用第二种配置方法。首先，需要下载quartz和spring对其提供支持的jar包。我这里采用的是quartz-2.2.1.jar，spring-context-support-4.2.4.RELEASE.jar，下载其他版本请注意包版本之间的兼容。","tags":[{"name":"文章","slug":"文章","permalink":"http://www.songxiaolang.com/tags/文章/"},{"name":"Quartz","slug":"Quartz","permalink":"http://www.songxiaolang.com/tags/Quartz/"}]},{"title":"AJAX POST数据中有特殊符号导致数据丢失的解决方法","date":"2016-09-22T05:27:22.000Z","path":"2016/09/22/data_exists_special_symbols/","text":"使用Ajax传送数据时，当数据中存在加号(+)、连接符(&amp;)或者百分号(%)时，服务器端接收数据时会丢失数据。分析Ajax传送数据的格式与Javascript的语法：1. “+”号：JavaScript解析为字符串连接符，所以服务器端接收数据时”+”会丢失变空格。2. “&amp;”号：JavaScript解析为变量连接符，所以服务器端接收数据时&amp;符号以后的数据都会丢失变空格。 解决方法是通过正则表达式进行编码替换(假设postStr是你想通过ajax传送的数据字符串)123postStr = postStr.replace(/\\%/g, \"%25\"); postStr = postStr.replace(/\\&amp;/g, \"%26\"); postStr = postStr.replace(/\\+/g, \"%2B\");","tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://www.songxiaolang.com/tags/Ajax/"},{"name":"文章","slug":"文章","permalink":"http://www.songxiaolang.com/tags/文章/"}]}]